<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BG Remover — Fixed Upload & Download</title>
  <meta name="description" content="High-quality client-side background remover (MediaPipe + BodyPix fallback). Fixed file upload and download functionality." />
  <style>
    :root{--bg:#071428;--card:#0b1220;--accent:#ff6a00;--muted:#9fb0c8}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter, system-ui, Arial;background:linear-gradient(180deg,var(--bg),#041023);color:#eaf2ff;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
    .wrap{width:100%;max-width:1000px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:12px;box-shadow:0 18px 60px rgba(0,0,0,0.6)}
    h1{margin:0 0 8px 0;font-size:1.25rem}
    .uploader{display:flex;gap:18px;align-items:flex-start}
    .left{flex:1;display:flex;flex-direction:column;gap:12px}
    .right{width:320px}
    .drop{border-radius:10px;border:2px dashed rgba(255,255,255,0.04);padding:14px;min-height:360px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;background:rgba(255,255,255,0.01)}
    input[type=file]{display:block;margin:8px 0}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    .btn{background:linear-gradient(90deg,var(--accent),#ff8a4b);color:#fff;border:none;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 8px 24px rgba(255,106,0,0.14)}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    canvas{max-width:100%;height:auto;border-radius:8px;background:transparent}
    label.field{display:block;color:var(--muted);font-size:0.9rem}
    input[type=range]{width:100%}
    .muted{color:var(--muted);font-size:0.9rem}
    footer{margin-top:12px;color:var(--muted);font-size:0.85rem;display:flex;justify-content:space-between}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Background Remover — Fixed Upload & Download</h1>
      <div class="muted">Uses MediaPipe SelfieSegmentation (best for portraits) with BodyPix fallback. Upload + Download fixed.</div>

      <div style="height:16px"></div>

      <div class="uploader">
        <div class="left">
          <div id="dropZone" class="drop" tabindex="0" aria-label="Upload or drop image">
            <div style="text-align:center;max-width:780px">
              <p id="hint">Drag & drop an image here<br>or</p>
              <input id="fileInput" type="file" accept="image/*" />
              <div style="margin-top:10px" class="controls">
                <button id="hqBtn" class="btn" disabled>Remove Background (HQ)</button>
                <button id="fastBtn" class="btn secondary" disabled>Fast Remove</button>
                <button id="resetBtn" class="btn secondary" disabled>Reset</button>
                <button id="downloadBtn" class="btn" disabled>Download PNG</button>
              </div>
            </div>
            <canvas id="resultCanvas" style="margin-top:12px;display:block"></canvas>
          </div>
        </div>

        <aside class="right">
          <div class="card" style="padding:12px">
            <label class="field">Edge blur (px): <span id="edgeBlurVal">8</span></label>
            <input id="edgeBlur" type="range" min="0" max="40" value="8">
            <label class="field">Alpha threshold (0..255): <span id="alphaVal">30</span></label>
            <input id="alphaThresh" type="range" min="0" max="255" value="30">
            <label class="field">Mask gamma (30..250): <span id="gammaVal">100</span></label>
            <input id="maskGamma" type="range" min="30" max="250" value="100">

            <div style="height:12px"></div>
            <div class="muted">Status: <span id="status">idle</span></div>
            <div style="height:8px"></div>
            <div class="muted">Tip: For best results use portrait photos with contrast between subject & background.</div>
          </div>
        </aside>
      </div>

      <footer>
        <div>© <span id="year"></span> BG Remover</div>
        <div class="muted">If you want studio-grade product removal later, we can add a server-side U²-Net.</div>
      </footer>
    </div>
  </div>

  <!-- MediaPipe SelfieSegmentation + BodyPix fallback -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.min.js"></script>

  <script>
    (function () {
      // DOM
      const fileInput = document.getElementById('fileInput');
      const dropZone = document.getElementById('dropZone');
      const resultCanvas = document.getElementById('resultCanvas');
      const ctx = resultCanvas.getContext('2d', { willReadFrequently: true });
      const hqBtn = document.getElementById('hqBtn');
      const fastBtn = document.getElementById('fastBtn');
      const resetBtn = document.getElementById('resetBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const statusEl = document.getElementById('status');
      const edgeBlur = document.getElementById('edgeBlur');
      const alphaThresh = document.getElementById('alphaThresh');
      const maskGamma = document.getElementById('maskGamma');
      const edgeBlurVal = document.getElementById('edgeBlurVal');
      const alphaVal = document.getElementById('alphaVal');
      const gammaVal = document.getElementById('gammaVal');
      const yearEl = document.getElementById('year');
      yearEl.textContent = new Date().getFullYear();

      // state
      let img = new Image();
      let originalImageData = null;
      let bodyPixNet = null;
      let useMediaPipe = (typeof SelfieSegmentation !== 'undefined');
      let segmenter = null;
      const MAX_DIM = 1400;

      // UI helpers
      function setStatus(t){ statusEl.textContent = t; }
      function setButtonsForImageLoaded(enabled = true){
        hqBtn.disabled = !enabled;
        fastBtn.disabled = !enabled;
        resetBtn.disabled = !enabled;
        downloadBtn.disabled = !enabled;
      }

      // wire range displays
      edgeBlur.addEventListener('input', ()=> edgeBlurVal.textContent = edgeBlur.value);
      alphaThresh.addEventListener('input', ()=> alphaVal.textContent = alphaThresh.value);
      maskGamma.addEventListener('input', ()=> gammaVal.textContent = maskGamma.value);

      // Setup MediaPipe if available
      if (useMediaPipe) {
        try {
          segmenter = new SelfieSegmentation({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
          });
          segmenter.setOptions({ modelSelection: 1 });
          setStatus('MediaPipe ready');
        } catch (e) {
          console.warn('MediaPipe init failed, will fallback to BodyPix:', e);
          useMediaPipe = false;
          setStatus('MediaPipe init failed — BodyPix fallback');
        }
      } else {
        setStatus('MediaPipe not available — BodyPix fallback');
      }

      // Drag & drop
      ['dragenter','dragover','dragleave','drop'].forEach(ev=>{
        dropZone.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); });
      });
      dropZone.addEventListener('drop', (e)=> { const f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) handleFile(f); });
      dropZone.addEventListener('click', ()=> fileInput.click());
      dropZone.addEventListener('keydown', (e)=> { if(e.key === 'Enter') fileInput.click(); });

      // file input
      fileInput.addEventListener('change', (e)=> {
        const f = e.target.files && e.target.files[0];
        if (f) handleFile(f);
        // reset input so same file can be chosen again if needed
        fileInput.value = '';
      });

      async function handleFile(file){
        try {
          if (!file.type || !file.type.startsWith('image/')) { alert('Please select an image file.'); return; }
          setStatus('Loading image...');
          const url = URL.createObjectURL(file);
          await loadImage(url);
          URL.revokeObjectURL(url);
          setStatus('Image loaded — ready');
          setButtonsForImageLoaded(true);
        } catch (err) {
          console.error(err);
          alert('Failed to load image: ' + err.message);
          setStatus('error loading image');
        }
      }

      function loadImage(src){
        return new Promise((resolve, reject) => {
          img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            try {
              let w = img.naturalWidth, h = img.naturalHeight;
              if (Math.max(w,h) > MAX_DIM) {
                const scale = MAX_DIM / Math.max(w,h);
                w = Math.round(w*scale); h = Math.round(h*scale);
              }
              resultCanvas.width = w; resultCanvas.height = h;
              ctx.clearRect(0,0,w,h);
              ctx.drawImage(img, 0, 0, w, h);
              originalImageData = ctx.getImageData(0,0,w,h);
              resolve();
            } catch (e) {
              reject(e);
            }
          };
          img.onerror = (e) => reject(new Error('Image load error'));
          img.src = src;
        });
      }

      // MediaPipe segmentation wrapper -> returns ImageBitmap (mask)
      function segmentWithMediaPipe(imageEl){
        return new Promise((resolve, reject) => {
          if (!segmenter) return reject(new Error('MediaPipe not initialized'));
          // set a one-time callback
          segmenter.onResults((results) => {
            // results.segmentationMask is an ImageBitmap (grayscale mask)
            if (!results || !results.segmentationMask) return reject(new Error('No segmentation mask'));
            resolve(results.segmentationMask);
          });
          // Send the HTMLImageElement to segmenter
          segmenter.send({image: imageEl}).catch(reject);
        });
      }

      // BodyPix fallback -> returns a Canvas element as mask
      async function ensureBodyPix(){
        if (bodyPixNet) return bodyPixNet;
        setStatus('Loading BodyPix (fallback)...');
        bodyPixNet = await bodyPix.load({architecture:'MobileNetV1', multiplier:0.75, outputStride:16});
        setStatus('BodyPix ready');
        return bodyPixNet;
      }

      async function segmentWithBodyPix(imageEl) {
        const net = await ensureBodyPix();
        const segmentation = await net.segmentPerson(imageEl, {internalResolution:'medium', segmentationThreshold:0.6});
        const w = resultCanvas.width, h = resultCanvas.height;
        const maskCanvas = document.createElement('canvas'); maskCanvas.width = w; maskCanvas.height = h;
        const mctx = maskCanvas.getContext('2d');
        const imgData = mctx.createImageData(w,h);
        for (let i=0; i<w*h; i++) {
          const v = segmentation.data[i] ? 255 : 0;
          imgData.data[i*4 + 0] = v;
          imgData.data[i*4 + 1] = v;
          imgData.data[i*4 + 2] = v;
          imgData.data[i*4 + 3] = 255;
        }
        mctx.putImageData(imgData, 0, 0);
        return maskCanvas;
      }

      // Core mask application logic - accepts maskSource (ImageBitmap or Canvas) and writes RGBA result onto resultCanvas
      function applyMaskMaskSource(maskSource) {
        const w = resultCanvas.width, h = resultCanvas.height;
        // draw mask to a temporary canvas so we can blur and read pixels
        const maskCanvas = document.createElement('canvas'); maskCanvas.width = w; maskCanvas.height = h;
        const mctx = maskCanvas.getContext('2d');
        // apply blur via canvas filter for smoother edges
        const blurPx = parseInt(edgeBlur.value, 10) || 0;
        mctx.filter = `blur(${blurPx}px)`;
        mctx.drawImage(maskSource, 0, 0, w, h);
        mctx.filter = 'none';

        // read mask data and combine with original image
        const maskData = mctx.getImageData(0,0,w,h).data;
        const orig = originalImageData.data;
        const out = ctx.createImageData(w,h);

        const thresh = parseInt(alphaThresh.value,10) || 0;
        const gammaVal = (parseInt(maskGamma.value,10) || 100) / 100.0;

        for (let i = 0; i < out.data.length; i += 4) {
          // copy RGB
          out.data[i]   = orig[i];
          out.data[i+1] = orig[i+1];
          out.data[i+2] = orig[i+2];
          // mask sample is in R channel (grayscale mask)
          const a = maskData[i]; // 0..255
          // gamma adjustment to keep soft hair natural but boost edges
          let m = Math.pow(a / 255, gammaVal) * 255;
          // threshold small speckles
          if (m < thresh) m = 0;
          out.data[i+3] = Math.round(m);
        }
        // draw final result
        ctx.clearRect(0,0,w,h);
        ctx.putImageData(out, 0, 0);
      }

      // HQ button -> tries MediaPipe then BodyPix fallback
      hqBtn.addEventListener('click', async () => {
        if (!originalImageData) { alert('Please upload an image first'); return; }
        setStatus('Processing (HQ) ...');
        try {
          if (useMediaPipe && segmenter) {
            const maskBitmap = await segmentWithMediaPipe(img);
            // maskBitmap is an ImageBitmap - pass directly to apply
            applyMaskMaskSource(maskBitmap);
            setStatus('Done — MediaPipe applied. Tweak blur/threshold for refinements.');
            return;
          }
          // otherwise fallback to BodyPix
          const maskCanvas = await segmentWithBodyPix(img);
          applyMaskMaskSource(maskCanvas);
          setStatus('Done — BodyPix applied (fallback).');
        } catch (err) {
          console.error('HQ segmentation error', err);
          setStatus('HQ failed, attempting fallback...');
          try {
            const maskCanvas = await segmentWithBodyPix(img);
            applyMaskMaskSource(maskCanvas);
            setStatus('Fallback BodyPix applied.');
          } catch (e) {
            console.error(e);
            setStatus('Both segmentation methods failed. See console.');
            alert('Segmentation failed. Check console for details.');
          }
        }
      });

      // Fast removal: quick chroma-like removal for solid backgrounds
      fastBtn.addEventListener('click', () => {
        if (!originalImageData) { alert('Please upload an image first'); return; }
        setStatus('Applying fast removal...');
        const w = resultCanvas.width, h = resultCanvas.height;
        const imgd = ctx.createImageData(w,h);
        imgd.data.set(originalImageData.data);
        const data = imgd.data;

        // sample background from corners
        const sampleIdx = [
          0,
          (w-1)*4,
          (w*h - 1)*4,
          (w*(h-1))*4
        ];
        let br=0, bg=0, bb=0;
        sampleIdx.forEach(idx => { br += data[idx]; bg += data[idx+1]; bb += data[idx+2]; });
        br /= sampleIdx.length; bg /= sampleIdx.length; bb /= sampleIdx.length;

        const tol = 90; // tolerance
        for (let i = 0; i < data.length; i += 4) {
          const dr = data[i] - br, dg = data[i+1] - bg, db = data[i+2] - bb;
          const dist = Math.sqrt(dr*dr + dg*dg + db*db);
          if (dist < tol) data[i+3] = 0;
        }
        ctx.putImageData(imgd, 0, 0);
        setStatus('Fast removal done.');
      });

      // Reset
      resetBtn.addEventListener('click', () => {
        if (!originalImageData) return;
        ctx.putImageData(originalImageData, 0, 0);
        setStatus('Reset to original');
      });

      // Download - robust toBlob + cleanup
      downloadBtn.addEventListener('click', () => {
        if (!resultCanvas.width) { alert('No result to download'); return; }
        setStatus('Preparing PNG...');
        resultCanvas.toBlob((blob) => {
          if (!blob) { alert('Export failed'); setStatus('Export failed'); return; }
          const link = document.createElement('a');
          const url = URL.createObjectURL(blob);
          link.href = url;
          link.download = 'transparent.png';
          // append to DOM to make click work on some browsers
          document.body.appendChild(link);
          link.click();
          // cleanup
          setTimeout(() => {
            URL.revokeObjectURL(url);
            link.remove();
            setStatus('Download started');
          }, 300);
        }, 'image/png');
      });

      // initial state
      setButtonsForImageLoaded(false);
      setStatus('idle');

      // expose small debug helper (optional) to console
      window.__bgRemover = {
        loadImage: (url) => loadImage(url)
      };
    })();
  </script>
</body>
</html>
